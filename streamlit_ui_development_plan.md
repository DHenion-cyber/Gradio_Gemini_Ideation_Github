# Streamlit UI Development Plan

This plan outlines the staged development of the Streamlit UI for the chatbot, with retesting of Trulens evaluations and Pytest after each implementation step to maintain existing functionality.

## Phase 1: Core UI Structure and Basic Components

### Step 1.1: Initial Streamlit Application Setup
*   **Implementation:** Create a minimal `streamlit_app.py` file with a basic Streamlit page structure (e.g., `st.set_page_config`, `st.title`).
*   **Retest:** Run `pytest` to ensure no existing tests are broken. Run Trulens evaluations if a basic runnable version of the app can be launched.

### Step 1.2: Integrate Basic UI Components
*   **Implementation:** Incorporate `ui_components.apply_responsive_css()` and `ui_components.privacy_notice()` into the `streamlit_app.py`.
*   **Retest:** Run `pytest`. Run Trulens evaluations.

## Phase 2: Session Management and Intake Flow

### Step 2.1: Implement Session State Initialization
*   **Implementation:** Integrate `initialize_conversation_state()` to manage the Streamlit session state, ensuring user ID, turn count, scratchpad, and conversation history are properly initialized or loaded.
*   **Retest:** Run `pytest`. Run Trulens evaluations.

### Step 2.2: Develop Intake Flow UI
*   **Implementation:** Create the UI elements for `run_intake_flow()`, presenting intake questions and capturing user responses. Implement the transition from "intake" to "ideation" stage.
*   **Retest:** Run `pytest`. Run Trulens evaluations.

## Phase 3: Core Chat Interaction

### Step 3.1: Display Conversation History
*   **Implementation:** Render the existing conversation history from the session state, distinguishing between user and assistant messages.
*   **Retest:** Run `pytest`. Run Trulens evaluations.

### Step 3.2: Implement User Input and Response Generation
*   **Implementation:** Add a Streamlit text input for user messages. Connect this input to `generate_assistant_response()`, which involves `llm_utils.build_prompt` and `llm_utils.query_gemini`. Display the assistant's response.
*   **Retest:** Run `pytest`. Run Trulens evaluations.

### Step 3.3: Integrate Response Rendering with Citations
*   **Implementation:** Use `ui_components.render_response_with_citations()` and `llm_utils.format_citations()` to display LLM responses with clickable inline citations.
*   **Retest:** Run `pytest`. Run Trulens evaluations.

## Phase 4: Advanced Chat Features and Monitoring

### Step 4.1: Value Proposition Navigation UI
*   **Implementation:** Integrate the UI for `navigate_value_prop_elements()`, allowing users to refine value proposition elements within the scratchpad.
*   **Retest:** Run `pytest`. Run Trulens evaluations.

### Step 4.2: Display Actionable Recommendations
*   **Implementation:** Implement the display of research-based suggestions generated by `generate_actionable_recommendations()`.
*   **Retest:** Run `pytest`. Run Trulens evaluations.

### Step 4.3: Out-of-Scope Handling UI
*   **Implementation:** Provide UI feedback to the user when `is_out_of_scope()` detects out-of-scope input.
*   **Retest:** Run `pytest`. Run Trulens evaluations.

### Step 4.4: Token Usage and Session Time Monitoring UI
*   **Implementation:** Display warnings or limits based on `update_token_usage()` and `enforce_session_time()`, potentially using `ui_components.progress_bar()`.
*   **Retest:** Run `pytest`. Run Trulens evaluations.

## Phase 5: Reporting and Finalization

### Step 5.1: Summary Report Generation and Download
*   **Implementation:** Integrate `generate_final_summary_report()` and `build_summary_from_scratchpad()`. Add a `ui_components.download_summary_button()` to allow users to download the session recap.
*   **Retest:** Run `pytest`. Run Trulens evaluations.

### Step 5.2: Refinement and Polish
*   **Implementation:** Review the entire UI for responsiveness, user experience, and visual consistency. Make any necessary adjustments.
*   **Retest:** Run `pytest`. Run Trulens evaluations.